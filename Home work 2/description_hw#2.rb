# Текстовки в задачах можна використовувати довільні, за умови, якщо в самій задачі не проситься конкретна текстовка.
# При написанні текстовок можна використовувати будь-яку мову, але бажано - англійську.
# Текстовка - в даному випадку це те, що ми виводимо користувачу в консоль.
# Задача під номером 3 являє собою задачу з зірочкою і НЕ є абсолютно обов'язковою.
# Задача під номером 4 являє собою задачу з двома зірочками і НЕ є обов'язковою, містить в своїх рішеннях
# поглиблені елементи деяких тем, які ми ще не проходили.

# Task #1
# Створити програму, яка буде отримувати від користувача назву тварини.
# В залежності від введеної тварини, виводити в консоль звук, який ця тварина видає.
# Вивід має бути у такому форматі - "Назва_тварини говорить - звук_тварини". Назва тварини має починатись з великої літери.
# Якщо була введена назва тварини, яка не покривається програмою (або щось ліве), то вивести в консоль відповідне повідомлення.
# Програма має покривати 4-5 назв тварин, в незалежності від регістру введених назв.
#
# Приклад взаємодії користувача з цією програмою:    |   Приклад взаємодії користувача з цією програмою:
# Введіть назву тварини:                             |   Введіть назву тварини:
# супер_вЕдміДь                                      |   сУпер_веДмідь
# Супер_ведмідь говорить - ведмежачий звук           |   Супер_ведмідь говорить - ведмежачий звук


# Task #2
# Написати програму, яка буде пропонувати користувачу ввести певне число.
# У відповідь на введене число, програма має виводити в консоль задане число помножене на 256 та пропонувати ввести ще одне число.
# Наведена вище логіка має повторюватись безліч кількість разів.
# У випадку, якщо програма отримала число, яке містить у своєму записі більше ніж одну одиницю (1),
# потрібно вивести користувачу якесь довільне повідомлення про завершення виконання цієї програми та зупинити програму.
#
# Приклад взаємодії користувача з цією програмою:
# Введіть число:
# 1
# Результат виконання: 256
# Введіть число:
# 171
# Умови недотримані, зупиняю виконання програми.


# Task #3*
# Реалізувати програму, яка надасть юзеру можливість ввести перелік своїх улюблених та найненавистніших міст (міста - англійською мовою).
# Ввід улюблених та найненавистніших міст має бути реалізований через два різні вводи.
# Міста вводяться через кому, потрібно обробляти випадки, коли між комами та самими назвами міст наявна певна кількість пробілів.
# На виході програма має повертати відсортований за назвою (алфавітом) перелік цих міст, також записаний через кому.
# Спочатку іде відсортований список улюблених міст, а потім через кому цей список має продовжуватись відсортованим списком найненавистніших міст.
#
# Приклад взаємодії користувача з цією програмою:
# Введіть улюблені міста:
# Cherkassy,  Toronto,    Tokyo, Lviv  , Paris
# Введіть найненавистніші Вами міста:
# Texas, New York,Indiana
# Результат виконання:
# Cherkassy, Lviv, Paris, Tokyo, Toronto, New York, Texas, Indiana


# Task #4**
# Вам дано умовну реалізацю аналогу методу .map, написаної виключно для масиву, на який зараз посилається змінна arr.
# Задачами є:
# - розібратись з тим чому і як цей кусок коду працює.
# - знайти відмінності між поведінкою звичайного .map
# - при бажанні виписати в якийсь коментар під кодом знайдені відмінності.
# - спробувати запустити цей метод без передачі блоку (ось ця конструкція { || })
# - змінити реалізацію цього методу так, щоб у випадку, коли блок не був переданий в цей метод, замість
# стандартного еррору виводити в консоль - "будьласка додайте блок".
# - змінити цей метод, так, щоб результат кожної ітераці перемножався на 2, якщо цим результатом є інтеджер.

arr = %w[a b c d] #це "рубішна" скорочена форма запису ось цього - ['a', 'b', 'c', 'd']

def arr.my_own_map
  collection_counter = 0
  result = []
  until collection_counter == size
    result << yield(self[collection_counter])
    collection_counter += 1
  end
  result
end